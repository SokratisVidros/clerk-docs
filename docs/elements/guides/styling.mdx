---
description: Learn how to bring your own styling when building with Clerk Elements.
---

# Styling Clerk Elements

Clerk Elements has been built to give you complete control over styling the rendered markup. Any Clerk Elements component that renders markup accepts a `className` prop, and an `asChild` prop is also exposed to change the rendered element entirely. To understand how this is done in practice, let's walk through a few different styling approaches. Use this basic sign in flow as a starting point:

```tsx
import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <Clerk.Provider name="google">Sign in with Google</Clerk.Provider>

        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Continue</SignIn.Action>
      </SignIn.Step>
      <SignIn.Step name="verifications">
        <SignIn.Strategy name="email_code">
          <Clerk.Field name="code">
            <Clerk.Label>Code</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Verify</SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

## Styling approaches

### Tailwind CSS

If you're already using Tailwind CSS, there is no additional setup required! Classes from Tailwind can be applied to most Clerk Elements components, rely on your editor's IntelliSense to see if `className` is a valid prop on a component you want to style.

### With existing components via `asChild`

Many of the Clerk Elements components accept an `asChild` prop that allows you to swap out the rendered element. This is useful if you have an existing design system or component library that you wish to use along with Clerk Elements.

```tsx
import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

import { Button } from '@components/button'
import { Input } from '@components/input'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <Clerk.Provider name="google" asChild>
          <Button>Sign in with Google</Button>
        </Clerk.Provider>

        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input asChild>
            <Input />
          </Clerk.Input>
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit asChild>
          <Button>Continue</Button>
        </SignIn.Action>
      </SignIn.Step>
      <SignIn.Step name="verifications">
        <SignIn.Strategy name="email_code">
          <Clerk.Field name="code">
            <Clerk.Label>Code</Clerk.Label>
            <Clerk.Input asChild>
              <Input />
            </Clerk.Input>
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit asChild>
            <Button>Continue</Button>
          </SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

Notice how the Clerk Elements components are wrapping the rendered `<Input>` and `<Button>` when `asChild` is used. This ensures the underlying event handlers and necessary props are passed along automatically.

<Callout type="info">

When using the `asChild` prop, you must ensure that the component is open for extension. Meaning: Your component must spread the incoming props and forward the ref to the underlying element. Here's an example of how you might implement a custom `<Input />` component:

```tsx
import { forwardRef } from 'react'

const CustomInput = forwardRef(function CustomInput(props, forwardedRef) {
  return <input ref={forwardedRef} {...props} className="custom-class" />
})
```

</Callout>

### CSS Modules

Classes from an imported CSS module can be applied to most Clerk Elements components.

```tsx
import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'
import styles from './sign-in.module.css'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start" className={styles.startStep}>
        <Clerk.Provider name="google" className={styles.provider}>Sign in with Google</Clerk.Provider>

        <Clerk.Field name="identifier">
          <Clerk.Label className={styles.label}>Email</Clerk.Label>
          <Clerk.Input className={styles.input} />
          <Clerk.FieldError className={styles.error} />
        </Clerk.Field>

        <SignIn.Action submit className={styles.submit}>Continue</SignIn.Action>
      </SignIn.Step>
      <SignIn.Step name="verifications" className={styles.verificationsStep}>
        <SignIn.Strategy name="email_code">
          <Clerk.Field name="code">
            <Clerk.Label className={styles.label}>Code</Clerk.Label>
            <Clerk.Input className={styles.input} />
            <Clerk.FieldError className={styles.error} />
          </Clerk.Field>

          <SignIn.Action submit className={styles.submit}>Verify</SignIn.Action>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

## State-based styling

In some cases you might want to style components based on their state. Clerk Elements exposes data attributes for this purpose, as well as components that expose the state programmatically to support more complex logic.

### Data attributes

#### Field components

`<Field>` and `<Input>` can be styled based on their validity state by targeting the `data-valid` or `data-invalid` attributes:

```css
.input {
  --border-color: gray;
  border: 1px solid var(--border-color);

  &[data-invalid] {
    --border-color: red;
  }
}
```

```tsx
<Clerk.Input className="input" />
```

### Function as children

If you need programmatic access to state for more complex styling, several components provide a function as children. This is useful when dealing with animations, or for conditionally rendering elements based on state.

For example: To access a field's state, use `<FieldState>`:

```tsx
<Clerk.Field name="email">
  <Clerk.FieldState>
    {(state) => state === 'invalid' && <ErrorIcon />}
  </Clerk.FieldState>
  <Clerk.Label>Email</Clerk.Label>
  <Clerk.Input />
  <Clerk.FieldError />
</Clerk.Field>
```
