---
description: Learn how to build a complete sign-in form with Clerk Elements.
---

# Build a sign-in flow

In this guide you'll learn how to build a complete sign-in flow using Clerk Elements.

<Callout type="info">

Clerk Elements currently only works with Next.js and [Clerk Core 2](https://clerk.com/changelog/2024-04-19). As it gets closer to a stable release, support for additional frameworks will be added. If your Next.js application is already using Clerk, make sure to [upgrade to Core 2](/docs/upgrade-guides/core-2/nextjs). If you're starting from scratch, follow the [Next.js quickstart](/docs/quickstarts/nextjs) before proceeding.

</Callout>

<Steps>

### Add a sign-in route

Create a new route in your Next.js application. The route needs to be an [optional catch-all route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments) so the sign-in flow can handled nested paths. Add the following snippet to `/app/sign-in/[[...sign-in]]/page.tsx`:

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx"
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
    </SignIn.Root>
  )
}
```

You've also added two imports, which you'll use as you build out the rest of the flow. `<SignIn.Root>` manages the sign-in state and handles connecting the components to Clerk's APIs.

### Add the start step

The Clerk authentication flows are made up of **steps**. Steps handle rendering the UI for each part of the flow. To allow users to create a sign-in attempt, the `start` step needs to be rendered. Use the `<SignIn.Step>` component to render this:

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx" {9-11}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <h1>Sign in to your account</h1>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

### Add form fields

Make it functional by adding fields. Use the Clerk Elements field components to render an `identifier` field, as well as the `<Connection>` component to allow users to sign in with a social connection, like Google:

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx" {12-22}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <h1>Sign in to your account</h1>

        <Clerk.Connection name="google">
          Sign in with Google
        </Clerk.Connection>

        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Continue</SignIn.Action>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

`<Clerk.Field>` takes care of wiring up the input with the label element, and `<Clerk.FieldError>` will render any field-specific errors that get returned from Clerk's API. You've also used the `<SignIn.Action>` component. This component provides common actions that are used throughout the flows. In this case, you're using the `submit` action to render a submit button for the start form.

<Callout type="info">
If your Clerk instance supports signing in with Google and doesn't require MFA, you should be able to complete a sign-in with the components you've rendered so far!
</Callout>

### Add verification

As one progresses through a sign-in attempt, your users may be asked to **verify** a number of authentication factors. This is done in the `verifications` step. Depending on your instance configuration and the state of the sign-in attempt, certain strategies will require different fields. To support conditional rendering based on the strategy being verified, you will use the `<SignIn.Strategy>` component. Assuming that your instance is configured to accept email codes, add the code necessary to accept them:

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx" {25-38}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <h1>Sign in to your account</h1>

        <Clerk.Connection name="google">
          Sign in with Google
        </Clerk.Connection>

        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Continue</SignIn.Action>
      </SignIn.Step>

      <SignIn.Step name="verifications">
        <SignIn.Strategy name="email_code">
          <h1>Check your email</h1>
          <p>We've sent a code to <SignIn.SafeIdentifier />.</p>

          <Clerk.Field name="code">
            <Clerk.Label>Email code</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

In the verifications step, you will need to render a `<SignIn.Strategy>` component for each authentication strategy that your instance supports. This will also handle multi-factor authentication (MFA) if it is enabled for your instance. Check out the [Sign-in reference](/docs/elements/reference/sign-in#strategy) for a full list of possible authentication strategies.

Verification is the final step in the sign-in flow. When a user has verified all required factors, the sign-in attempt will be complete and they will be signed in.

### Add password support

If your instance is configured to support authenticating with passwords, you'll need to add a few additional steps and verification strategies. You can choose if you want to support providing a password in the start step with an additional field, or as an additional verification strategy. For this guide, add it as a standalone verification strategy.

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx" {39-65,68-94}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <h1>Sign in to your account</h1>

        <Clerk.Connection name="google">
          Sign in with Google
        </Clerk.Connection>

        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Continue</SignIn.Action>
      </SignIn.Step>

      <SignIn.Step name="verifications">
        <SignIn.Strategy name="email_code">
          <h1>Check your email</h1>
          <p>We've sent a code to <SignIn.SafeIdentifier />.</p>

          <Clerk.Field name="code">
            <Clerk.Label>Email code</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Strategy>

        <SignIn.Strategy name="password">
          <h1>Enter your password</h1>

          <Clerk.Field name="password">
            <Clerk.Label>Password</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
          <SignIn.Action navigate="forgot-password">
            Forgot password?
          </SignIn.Action>
        </SignIn.Strategy>

        <SignIn.Strategy name="reset_password_email_code">
          <h1>Check your email</h1>
          <p>We've sent a code to <SignIn.SafeIdentifier />.</p>

          <Clerk.Field name="code">
            <Clerk.Label>Email code</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>

      <SignIn.Step name="forgot-password">
        <h1>Forgot your password?</h1>

        <SignIn.SupportedStrategy name="reset_password_email_code">
          Reset password
        </SignIn.SupportedStrategy>

        <SignIn.Action navigate="back">Go back</SignIn.Action>
      </SignIn.Step>

      <SignIn.Step name="reset-password">
        <h1>Reset your password</h1>

        <Clerk.Field name="password">
          <Clerk.Label>New password</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <Clerk.Field name="confirmPassword">
          <Clerk.Label>Confirm password</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Reset password</SignIn.Action>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

When accepting passwords, you also need a way to let users reset them. To support this, you've added two new steps: `forgot-password` and `reset-password`. The `forgot-password` step lets your user trigger the reset flow. First, it sends an email code that needs to be verified, secondly the `reset-password` step then accepts a new password upon successful verification. If your instance is configured to accept SMS codes, the `reset_password_phone_code` strategy can also be used.

In the `forgot-password` step, you'll notice that a new component is rendered, [`<SignIn.SupportedStrategy>`](/docs/elements/reference/sign-in#supportedstrategy). In the `forgot-password` and `choose-strategy` steps, `<SignIn.SupportedStrategy>` is used to trigger a verification of a supported strategy. In this case, you're using it to trigger verification of one of the `reset_password` strategies.

<Callout>
  If your instance isn't configured to use passwords, or any of the strategies outlined here, Clerk Elements will log a warning to the console during development.
</Callout>

### Customize and add styling

You might have noticed by now that none of components rendered so far come with their own styling. This is by design! With the exception of `<SignIn.Root>` and `<SignIn.Strategy>`, every component rendered so far can be styled. You can use the `className` prop to add custom classes to each component. Check out the [styling guide](/docs/elements/guides/styling) for a more in-depth guide on styling Clerk Elements.

If you're looking to customize the UI even further, check out additional Clerk Elements components like [`<Loading>`](/docs/elements/reference/common#loading) and [`<FieldState>`](/docs/elements/reference/common#fieldstate).

</Steps>
